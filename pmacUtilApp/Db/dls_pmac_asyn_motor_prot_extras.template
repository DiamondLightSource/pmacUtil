## PMAC motor axis protection PLC support template.
## Use in conjunction with PLC4_protection.pmc to control
## and monitor the operation of encoder loss and limit protection.

#% macro, SPORT, Asyn port used to communicate with the PMAC 
#% macro, ADDR, The axis number
#% macro, PROTENABLE, Set to 1 to enable the protection system for this axis
#% macro, RECOVERVEL, The velocity to use for recovery, in motor steps per millisecond

## Enable protection, '1' to enable.
record(bo, "$(P)$(M):PROT:ENABLE") {
  field(VAL, "$(PROTENABLE)")
  field(ZNAM, "Disable")
  field(ONAM, "Enable")
  field(FLNK, "$(P)$(M):PROT:RDCONFIG.PROC")
}

## Recovery velocity, motor steps per ms.
record(ao, "$(P)$(M):PROT:RECOVERVEL") {
  field(VAL, "$(RECOVERVEL)")
  field(PREC, "4")
  field(FLNK, "$(P)$(M):PROT:RDCONFIG.PROC")
}

## The recover command.  Write a '1' to recover from
## encoder loss or limit hitting
record(bo, "$(P)$(M):PROT:RECOVER") {
  field(VAL, "0")
  field(ZNAM, "Idle")
  field(ONAM, "Recover")
  field(FLNK, "$(P)$(M):PROT:DORECOVER")
}

## Detects the zero->one edge that triggers the command
record(calcout, "$(P)$(M):PROT:DORECOVER") {
  field(INPA, "$(P)$(M):PROT:RECOVER")
  field(CALC, "A")
  field(OOPT, "Transition To Non-zero")
  field(OUT, "$(P)$(M):PROT:RDCONFIG.PROC")
}

## Calculates the read config string.  Processed
## only once at startup.
record(scalcout, "$(P)$(M):PROT:RDCONFIGSTR") {
  field(DOPT, "Use OCAL")
  field(OCAL, "$P('P4%02d',$(ADDR))")
  field(OUT, "$(P)$(M):PROT:RDCONFIG.AOUT")
  field(PINI, "1")
  field(FLNK, "$(P)$(M):PROT:RDCONFIG.PROC")
}

## Read the current state of the config variable
record(asyn, "$(P)$(M):PROT:RDCONFIG") {
  field(PORT, "$(SPORT)")
  field(TMOT, "5")
  field(FLNK, "$(P)$(M):PROT:CONFIG")
}

## Convert the string into a value
record(scalcout, "$(P)$(M):PROT:CONFIG") {
  field(SCAN, "Passive")
  field(DTYP, "Soft Channel")
  field(VAL, "0")
  field(CALC, "SSCANF(AA, '%f')")
  field(INAA, "$(P)$(M):PROT:RDCONFIG.AINP")
  field(PREC, "0")
  field(FLNK, "$(P)$(M):PROT:CALCCONFIG")
}

## Calculates the config value to write
record(calc, "$(P)$(M):PROT:CALCCONFIG") {
  field(INPA, "$(P)$(M):PROT:ENABLE")
  field(INPB, "$(P)$(M):PROT:RECOVER")
  field(INPC, "$(P)$(M):PROT:CONFIG")
  field(INPD, "$(P)$(M):PROT:RECOVERVEL")
  field(CALC, "A|(B<<1)|(C&252)|(D*65536&16776960)")
  field(FLNK, "$(P)$(M):PROT:WRCONFIGSTR")
}

## Calculates the write config string
record(scalcout, "$(P)$(M):PROT:WRCONFIGSTR") {
  field(DOPT, "Use CALC")
  field(INPA, "$(P)$(M):PROT:CALCCONFIG")
  field(CALC, "$P('P4%02d',$(ADDR))+$P('=%d',A)")
  field(OUT, "$(P)$(M):PROT:WRCONFIG.AOUT PP")
}

## Write the config word back to the PMAC
record(asyn, "$(P)$(M):PROT:WRCONFIG") {
  field(PORT, "$(SPORT)")
  field(TMOT, "5")
  field(FLNK, "$(P)$(M):PROT:CLRRECOVER")
}

## Zero the recover command
record(seq, "$(P)$(M):PROT:CLRRECOVER") {
  field(DOL1, "0")
  field(LNK1, "$(P)$(M):PROT:RECOVER")
}

## Create the string for the state read command
record(scalcout, "$(P)$(M):PROT:RDSTATESTR") {
  field(DOPT, "Use CALC")
  field(CALC, "$P('P4%02d',$(ADDR)+64)")
  field(OUT, "$(P)$(M):PROT:RDSTATE.AOUT")
  field(PINI, "1")
}

## Read the protection state variable
record(asyn, "$(P)$(M):PROT:RDSTATE") {
  field(SCAN, "1 second")
  field(PORT, "$(SPORT)")
  field(TMOT, "5")
  field(FLNK, "$(P)$(M):PROT:CALCSTATE")
}

## Convert the string into a value
record(scalcout, "$(P)$(M):PROT:CALCSTATE") {
  field(CALC, "SSCANF(AA, '%f')")
  field(INAA, "$(P)$(M):PROT:RDSTATE.AINP")
  field(PREC, "0")
  field(OUT, "$(P)$(M):PROT:STATE.RVAL PP")
}

## The current protection state
record(mbbi, "$(P)$(M):PROT:STATE") {
  field(DTYP, "Raw Soft Channel")
  field(SHFT, "4")
  field(ZRVL, "0")
  field(ONVL, "1")
  field(TWVL, "2")
  field(THVL, "3")
  field(FRVL, "4")
  field(FVVL, "5")
  field(SXVL, "6")
  field(SVVL, "7")
  field(EIVL, "8")
  field(NIVL, "9")
  field(TEVL, "10")
  field(ZRST, "None")
  field(ONST, "Normal")
  field(TWST, "On Limit")
  field(THST, "Recover Limit")
  field(FRST, "Encoder Loss")
  field(FVST, "Homing")
  field(SXST, "Not Protected")
  field(SVST, "Closing loop")
  field(EIST, "Closing loop")
  field(NIST, "Closing loop")
  field(TEST, "Lock out")
}


