CLOSE

;###############################################
; Define motion of B22's optics box
; Original Author: Tom Cobb
; Used variables: Q71..Q79, Q81..Q89, Q91..Q99, Q200..
; Macros (and example values): 
; COORD = $(COORD) ;CS number (only works for CS 1..9), e.g. 2
; PLC = $(PLC) ;PLC number, should be CS number+15, e.g. 17
; M9PITCH = $(M9PITCH) ;Axisnum for M9 pitch actuator, e.g. 1
; M9ROLL = $(M9ROLL) ;Axisnum for M9 roll actuator, e.g. 2
; XM9 = $(XM9) ;Lateral distance between actuator and pivot ball on M9 in mm
; YM9 = $(XM9) ;Distance between M9 pitch actuator and pivot ball on M9 in mm
; M10PITCH = $(M10PITCH) ;Axisnum for M10 pitch actuator, e.g. 3
; M10ROLL = $(M10ROLL) ;Axisnum for M10 roll actuator, e.g. 4
; XM10 = $(XM10) ;Lateral distance between actuator and pivot ball on M10 in mm
; YM10 = $(XM10) ;Distance between M10 pitch actuator and pivot ball on M10 in mm
; LM9M10 = $(LM9M10) ;Distance between M9 and M10 centres in mm
; MRES = $(MRES) ;Mres of motor record
;################################################

; Note that we are providing a CS axis with an MRES of $(MRES) and EGU in rad/deg
; depending on the setting of i15
; This is needed as the motor record will only move in full steps

; Change to CS$(COORD)
&$(COORD)

; Set relevant axes to use kinematics
#$(M9PITCH)->I
#$(M9ROLL)->I
#$(M10PITCH)->I
#$(M10ROLL)->I

; These are set by mres_reporting_motor.template
#define M9PITCHMRES P(100+$(M9PITCH))
#define M9PITCHOFF  P(300+$(M9PITCH))
#define M9ROLLMRES P(100+$(M9ROLL))
#define M9ROLLOFF  P(300+$(M9ROLL))
#define M10PITCHMRES P(100+$(M10PITCH))
#define M10PITCHOFF  P(300+$(M10PITCH))
#define M10ROLLMRES P(100+$(M10ROLL))
#define M10ROLLOFF  P(300+$(M10ROLL))

; Set epics motor record to look at this address - 1
#define $(XEXIT)     6
#define $(YEXIT)     7
#define $(THETAEXIT) 8
#define $(PHIEXIT)   9

; Setup the inputs, all are in mm
#define XM9      Q200
#define YM9      Q201
#define XM10     Q202
#define YM10     Q203
#define LM9M10   Q204
XM9 = $(XM9)
YM9 = $(YM9)
XM10 = $(XM10)
YM10 = $(XM10)
LM9M10 = $(LM9M10)

; Some temp vars for kinematics
#define THETAM9  Q207
#define PHIM9    Q208
#define THETAM10 Q209
#define PHIM10   Q210

OPEN FORWARD
; This kinematic translates actuators into exit X, Y, Theta, and Phi
; Xexit in mm = ThetaM9 x lM9M10 / 1000
; Yexit in mm = PhiM9 x lM9M10 / 1000
; ThetaExit in mrad = 2 x ThetaM9 + 2 x ThetaM10
; PhiExit in mrad = 2 x PhiM9 + 2 x PhiM10
; where:
;   ThetaM9 in mrad = M9Pitch x 1000 / xM9
;   PhiM9 in mrad = M9Roll x 1000 / yM9
;   ThetaM10 in mrad = M10Pitch x 1000 / xM10
;   PhiM10 in mrad = M10Roll x 1000 / yM10
CLEAR
	; get angles from actuators
    THETAM9 = (M9PITCHMRES*P$(M9PITCH)+M9PITCHOFF) * 1000 / XM9
    PHIM9 = (M9ROLLMRES*P$(M9ROLL)+M9ROLLOFF) * 1000 / YM9
    THETAM10 = (M10PITCHMRES*P$(M10PITCH)+M10PITCHOFF) * 1000 / XM10
    PHIM10 = (M10ROLLMRES*P$(M10ROLL)+M10ROLLOFF) * 1000 / YM10
    ; calculate exit values from angles
	Q$(XEXIT) = (THETAM9 * LM9M10) / $(MRES) / 1000
	Q$(YEXIT) = (PHIM9 * LM9M10) / $(MRES) / 1000
	Q$(THETAEXIT) = 2 * (THETAM9 + THETAM10) / $(MRES)
	Q$(PHIEXIT) = 2 * (PHIM9 + PHIM10) / $(MRES)
CLOSE

; Some temp vars for kinematics
#define THETAM9  Q211
#define PHIM9    Q212
#define THETAM10 Q213
#define PHIM10   Q214
	
OPEN INVERSE
; This kinematic translates exit X, Y, Theta, and Phi into actuator positions
; M9Pitch in mm = ThetaM9 * xM9 / 1000
; M9Roll in mm = PhiM9 * yM9 / 1000
; M10Pitch in mm = ThetaM10 * xM10 / 1000
; M10Roll in mm = PhiM10 * yM10 / 1000
; where:
;   ThetaM9 in mrad = Xexit * 1000 / lM9M10
;   PhiM9 in mrad = Yexit * 1000 / lM9M10
;   ThetaM10 in mrad = (ThetaExit - 2 x ThetaM9) / 2
;   PhiM10 in mrad = (PhiExit - 2 x PhiM9) / 2
CLEAR
	; get angles from exit
    THETAM9 = Q$(XEXIT) * $(MRES) * 1000 / LM9M10
    PHIM9 = Q$(YEXIT) * $(MRES) * 1000 / LM9M10
    THETAM10 = (Q$(THETAEXIT) * $(MRES) - 2 * THETAM9) / 2
    PHIM10 = (Q$(PHIEXIT) * $(MRES) - 2 * PHIM9) / 2
    ; calculate actuator values from angles
	P$(M9PITCH) = (THETAM9 * XM9 / 1000 - M9PITCHOFF) / M9PITCHMRES
	P$(M9ROLL) = (PHIM9 * YM9 / 1000 - M9ROLLOFF) / M9ROLLMRES
	P$(M10PITCH) = (THETAM10 * XM10 / 1000 - M10PITCHOFF) / M10PITCHMRES
	P$(M10ROLL) = (PHIM10 * YM10 / 1000 - M10ROLLOFF) / M10ROLLMRES
CLOSE	

; Some temp vars for PLC reporting
#define THETAM9  Q215
#define PHIM9    Q216
#define THETAM10 Q217
#define PHIM10   Q218

OPEN PLC $(PLC)
; PLC for position reporting
CLEAR
; As forward kinematic, but with Px = mx62/(Ix08*32)
#define M9PITCHVAL m$(M9PITCH)62/(I$(M9PITCH)08*32)
#define M9ROLLVAL m$(M9ROLL)62/(I$(M9ROLL)08*32)
#define M10PITCHVAL m$(M10PITCH)62/(I$(M10PITCH)08*32)
#define M10ROLLVAL m$(M10ROLL)62/(I$(M10ROLL)08*32)
; Put deadband into Q9x
#define M9PITCHDB  i$(M9PITCH)65*M9PITCHMRES/16
#define M9ROLLDB  i$(M9ROLL)65*M9ROLLMRES/16
#define M10PITCHDB  i$(M10PITCH)65*M10PITCHMRES/16
#define M10ROLLDB  i$(M10ROLL)65*M10ROLLMRES/16
ADDRESS&$(COORD)
	; get angles from actuators
    THETAM9 = (M9PITCHMRES*M9PITCHVAL+M9PITCHOFF) * 1000 / XM9
    PHIM9 = (M9ROLLMRES*M9ROLLVAL+M9ROLLOFF) * 1000 / YM9
    THETAM10 = (M10PITCHMRES*M10PITCHVAL+M10PITCHOFF) * 1000 / XM10
    PHIM10 = (M10ROLLMRES*M10ROLLVAL+M10ROLLOFF) * 1000 / YM10
    ; calculate exit values from angles
	Q8$(XEXIT) = (THETAM9 * LM9M10) / $(MRES) / 1000
	Q8$(YEXIT) = (PHIM9 * LM9M10) / $(MRES) / 1000
	Q8$(THETAEXIT) = 2 * (THETAM9 + THETAM10) / $(MRES)
	Q8$(PHIEXIT) = 2 * (PHIM9 + PHIM10) / $(MRES)
	; calculate deadbands
	Q9$(XEXIT) = ABS(M9PITCHDB * 1000 / XM9 * LM9M10 / $(MRES))
	Q9$(YEXIT) = ABS(M10PITCHDB * 1000 / YM9 * LM9M10 / $(MRES))
	Q9$(THETAEXIT) = ABS(2 * (M9PITCHDB * 1000 / XM9 + M10PITCHDB * 1000 / XM10) / $(MRES))
	Q9$(PHIEXIT) = ABS(2 * (M9ROLLDB * 1000 / YM9 + M10ROLLDB * 1000 / YM10) / $(MRES))
CLOSE
ENABLE PLC $(PLC)


