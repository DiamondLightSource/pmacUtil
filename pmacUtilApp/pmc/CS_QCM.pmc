CLOSE

;###############################################
; Define motion for Energy in Diamond QCM
; Original Author: Pete Leicester
; Used variables: Q71..Q79, Q81..Q89, Q91..Q99, Q20..Q23, Q110, Q111, P$(PLC)00
; Macros (and example values): 
; COORD - CS number (only works for CS 1..9), e.g. 2
; PLC - PLC number, should be CS number+15, e.g. 17
; BRAGG1 - Axisnum for Bragg1, e.g. 2
; BRAGG2 - Axisnum for Bragg2, e.g. 3
; RADMRES1 - resolution for bragg1 (NB keep sign same as real bragg1 motor MRES)
; RADMRES2 - resolution for bragg2 (NB keep sign same as real bragg2 motor MRES)
; (Note1 the real bragg1/2 motors can have any resolution/unit desired
;  so can be in steps, degrees or rad (if set the same as RADMRES))
; (Note2  remember to increase the resolution by *32 to match the pmacSetAxisScale(3,1,32) 
;  calls in the start up file)
; (Note3 the CS energy motor resolution should be set to 0.00001 kEv (0.01 Ev)
;
; Additional controls that could be changed from EPIC's
; Q23 - Mode (0= energy and offset, 1= two independent energy axis)
;
; Readbacks for epics
; Q111 - crystal spacing (3.13475 for Si(111), 1.637069796 for Si(311)). Value defined by switch wired to pmac input.
;
; NB THIS TEMPLATE REQUIRES the epics startup file to define a scale factor of 32 on both bragg motors
;    (i.e. pmacSetAxisScale(3,1,32) and pmacSetAxisScale(3,2,32) )
;
;################################################


; Change to CS$(COORD)
&$(COORD)

; Set relevant axes to use kinematics
#$(BRAGG1)->I
#$(BRAGG2)->I

; Trig mode (0=degrees,1=radians)
i15=1

; Mode of operation
; 0 = Energy and EnergyOffset compound motors (i.e. bragg2=bragg1+offset)
; 1 = Independent energy axis (i.e. independent bragg1 and bragg2)
; define default value for epics to overwrite
Q23=0

; These are set by mres_reporting_motor.template
#define B1MRES P(100+$(BRAGG1))
#define B1OFF  P(300+$(BRAGG1))
#define B2MRES P(100+$(BRAGG2))
#define B2OFF  P(300+$(BRAGG2))

 

; Setup energy calculation variables
; Energy in keV = {Evlamda}/(2*{d}*sin(Bragg))
; where Bragg is in rad's
;       Evlamda = 12.3985
;       d = crystal spacing in angstrom (dependent on temperature)
;       d (at room temp) = 5.430845307 / sqrt(h^2+k^2+l^2) and h,k,l = 1,1,1 or 3,1,1 depending on silicon type  
;       d (at room temp) = 3.1355 for Si(111) 
;       d (at room temp) = 1.637461471 for Si(311)  
;       d (at liguid N2 temp) = 5.429546269 / sqrt(h^2+k^2+l^2) and h,k,l = 1,1,1 or 3,1,1 depending on silicon type 
;       d (at liguid N2 temp) = 3.13475 for Si(111)
;       d (at liguid N2 temp) = 1.637069796 for Si(311)
; { This boils down to at room temp
;         Energy in keV = 1.977116887 / sin(Bragg) for Si(111)
;      or Energy in keV = 3.785890606 / sin(Bragg) for Si(311) 
;   and at liguid N2 temp
;         Energy in keV = 1.977589919 / sin(Bragg) for Si(111)
;      or Energy in keV = 3.786796394 / sin(Bragg) for Si(311) }
;

; Define Evlambda
Q110=12.3985
; Define d = crystal spacing in angstrom Si(111) (default value for switch input to overwrite)
Q111=3.13475

; NB Q112 is used for debugging - value indicates where last error occurred in kinematic

OPEN FORWARD
; This kinematic is for the QCM energy in kEv
; need to multiply everything by 100000 to give decent CS motor MRES value(i.e. 0.00001)
; X = Q7 = Energy1 in kEv = {Evlamda}/(2*{d}*sin(Bragg1))
; Y = Q8 = EnergyOffset in kEv = Energy1 - Energy2
;                              = Energy1 - {Evlamda}/(2*{d}*sin(Bragg2))
; Z = Q9 = Energy2 in kEv = {Evlamda}/(2*{d}*sin(Bragg2))
; NB We scale the B1OFF and B2OFF by 32 because of the epics pmacSetAxisScale(3,1,32)
CLEAR
;Q20=2*Q111*SIN(B1MRES*P$(BRAGG1)+B1OFF)
;Q21=2*Q111*SIN(B2MRES*P$(BRAGG2)+B2OFF)
Q20=2*Q111*SIN($(RADMRES1)*(P$(BRAGG1)+(B1OFF/(B1MRES*32))))
Q21=2*Q111*SIN($(RADMRES2)*(P$(BRAGG2)+(B2OFF/(B2MRES*32))))
IF (ABS(Q20)>0.0001)
    Q7=100000*Q110/(Q20)
    IF (ABS(Q21)>0.0001)
        Q9=100000*Q110/(Q21)
;        Q8=Q7-Q9
        Q8=Q9-Q7
    ELSE
        M5$(COORD)82=1
        Q112=4
    ENDIF            
ELSE
    M5$(COORD)82=1
    Q112=5
ENDIF
CLOSE

OPEN INVERSE
CLEAR
; P$(BRAGG1) = Bragg1 position = arcsin({Evlamda}/(2*{d}*(Energy1)) 
; P$(BRAGG2) = Bragg2 position = arcsin({Evlamda}/(2*{d}*(Energy2))
;                 where Energy2 = Energy1(Q7) - EnergyOffset(Q8)
;           or Bragg2 position = arcsin({Evlamda}/(2*{d}*(Energy2))
Q20=100000*Q110/(2*Q111*Q7)
Q21=100000*Q110/(2*Q111*(Q7+Q8))
Q22=100000*Q110/(2*Q111*Q9)
IF (ABS(Q20)<1)
;    P$(BRAGG1)=(ASIN(Q20)-B1OFF)/B1MRES
    P$(BRAGG1)=(ASIN(Q20)/$(RADMRES1))-(B1OFF/(B1MRES*32))
    IF (Q23=0)
        IF (ABS(Q21)<1)
;            P$(BRAGG2)=(ASIN(Q21)-B2OFF)/B2MRES
            P$(BRAGG2)=(ASIN(Q21)/$(RADMRES2))-(B2OFF/(B2MRES*32))
        ELSE
            M5$(COORD)82=1
            Q112=1
        ENDIF
    ELSE
        IF (ABS(Q22)<1)
;            P$(BRAGG2)=(ASIN(Q22)-B2OFF)/B2MRES
            P$(BRAGG2)=(ASIN(Q22)/$(RADMRES2))-(B2OFF/(B2MRES*32))
        ELSE
            M5$(COORD)82=1
            Q112=2
        ENDIF
    ENDIF    
ELSE
    M5$(COORD)82=1
    Q112=3
ENDIF
CLOSE

;
;
OPEN PLC $(PLC)
; PLC for position reporting
CLEAR
; As forward kinematic, but with Px = mx62/(Ix08*32)
#define B1VAL m$(BRAGG1)62/(I$(BRAGG1)08*32)
#define B2VAL m$(BRAGG2)62/(I$(BRAGG2)08*32)
; Put deadband into Q9x
;#define B1DB  i$(BRAGG1)65*B1MRES/16
;#define B2DB  i$(BRAGG2)65*B2MRES/16
#define B1DB  i$(BRAGG1)65*$(RADMRES1)/16
#define B2DB  i$(BRAGG2)65*$(RADMRES2)/16
ADDRESS&$(COORD)
;P$(PLC)00=2*Q111*SIN(B1MRES*B1VAL+B1OFF)
;P$(PLC)01=2*Q111*SIN(B2MRES*B2VAL+B2OFF)
P$(PLC)00=2*Q111*SIN($(RADMRES1)*(B1VAL+(B1OFF/(B1MRES*32))))
P$(PLC)01=2*Q111*SIN($(RADMRES2)*(B2VAL+(B2OFF/(B2MRES*32))))
IF (ABS(P$(PLC)00)>0.0001 And ABS(P$(PLC)01)>0.0001)
    Q87=100000*Q110/P$(PLC)00
    Q89=100000*Q110/P$(PLC)01
    Q88=Q89-Q87
    ; Approximations to deadband as a calculated value is not worth the effort
    Q97=2000000*ABS(B1DB)
    Q98=1000000*(ABS(B1DB)+ABS(B2DB))
    Q99=2000000*ABS(B2DB)
;ELSE
;    M5$(COORD)82=1
ENDIF
CLOSE

ENABLE PLC $(PLC)


;################################################
; Note on calibrating the energy in EPICS
; In order to correct the energy readback value linearly across the whole range 
; of bragg it is necessary to adjust the EPICS motor offset of the real bragg 
; motors BRAGG1 and BRAGG2. The resolution of these motors is defined by B1MRES 
; and B2MRES.
; Therefore (if 'actual' is what it should read and 'readback' is the current energy value generated by the PLC):
;   epics offset correction(real b1 mtr) = ( ( bragg1(actual in rad) - bragg1(readback in rad) ) / RADMRES1 ) * B1MRES * 32 
;   epics offset correction(real b2 mtr) = ( ( bragg2(actual in rad) - bragg2(readback in rad) ) / RADMRES2 ) * B2MRES * 32 
; and
;   bragg1 in rad = arcsin(  Evlambda  / ( 2d * Energy1(kEv) ) )
;   bragg2 in rad = arcsin(  Evlambda  / ( 2d * Energy2(kEv) ) )
;
;################################################

